### Human-Computer Interaction (HCI)

In interacting with a computer, **human input** becomes the **computer’s output** and vice versa. Human input mainly occurs through the senses, while output occurs through motor controls.

#### Key Senses in HCI
The most important senses in HCI are:
- **Vision**
- **Hearing**
- **Movement**
- **Touch**

**Vision**: Visual perception can be divided into two stages:
1. Physical reception of a stimulus
2. Processing and interpretation of the stimulus

The eye functions as a mechanism for receiving light and converting it into electrical energy.

#### Memory Types
Memory has three primary functions:
- **Sensory Memory**
- **Short-Term Memory**: Activated when attention is given to sensory memories.
- **Long-Term Memory**: Formed when short-term memory is rehearsed.


### About HCI

**Human-Computer Interaction (HCI)** is a field concerned with the design, evaluation, and implementation of interactive computing systems for human use, as well as the study of related phenomena. The main goal is to create safe, usable systems that prioritize the user.

#### Components of HCI
1. **Human**: Can be an individual user or a group of users.
2. **Computer**: Any technology from a desktop computer to a large system.
3. **Interaction**: The direct or indirect communication between human and computer.


### Goals of HCI
- Enhance system **safety**, **utility**, **effectiveness**, **efficiency**, and **usability**.
- Create functional, safe, and user-centered systems by:
  - Understanding how people interact with technology.
  - Developing tools and techniques for creating suitable systems.
  - Fostering effective, safe interactions.
  - Prioritizing users in system design.


### Usability

**Usability** measures how effective, efficient, and satisfying a system is for users to achieve their goals. A **usable system** should be:
- Easy to use and learn
- Easy to remember
- Efficient and safe
- Enjoyable

#### Importance of Usability
1. **Good user interfaces**:
   - Increase revenue potential for a company
   - Boost user trust and loyalty
   - Improve user satisfaction
2. **Poor user interfaces**:
   - Can be frustrating and even dangerous
   - Lead to mistakes in data entry and operations
   - Make features inaccessible
   - Cause system rejection and failure


### Key Factors in HCI System Design
- **Organizational Factors**
- **Environmental Factors**
- **User Characteristics**
- **Task Requirements**
- **User Interface Design**
- **System Constraints**
- **System Functionality**
- **Productivity Considerations**


### Fields Contributing to HCI
- **Computer Science**
- **Engineering** (Ergonomics)
- **Graphic Design**
- **Technical Writing**
- **Linguistics**
- **Artificial Intelligence** (AI)


### Design in HCI
**Design** involves achieving goals within constraints (guidelines and rules). Constraints include:
- **Materials** used
- **Standards** to follow
- **Cost and Time**
- **Safety and Health** requirements

#### Affordance in Design
Affordance is the potential for an action within an environment or on an object.

Types of affordance:
- **Perceived Affordance**: Actions a user perceives as possible, which suggest how an object can be used.
- **Real Affordance**: Actions that are actually possible.


---
05/11/24
### **Mapping**
Mappings define the relationships between controls and their effects on a system.  

**Types of Mapping**  
1. **Arbitrary Mapping**  
   - Relies on labels and memory to establish the relationship between control and effect.  
2. **Paired Mapping**  
   - Offers some correlation between controls and effects but may still lead to confusion.  
3. **Full-Natural Mapping**  
   - No ambiguity; users can intuitively understand and remember the relationship without the need for labels.  

**Constraints**  
1. **Physical**  
   - Limitations imposed by physical properties or boundaries.  
2. **Semantic**  
   - Based on an individual's knowledge of the situation and the world.  
3. **Cultural**  
   - Rooted in cultural conventions and norms.  
4. **Logical**  
   - Utilizes logical relationships, such as those in natural mappings.  

---

### **HCI Software Process**
1. **System Development Life Cycle (SDLC)**  
   - A structured process for software development.  
2. **Usability Engineering Life Cycle**  
   - Focuses on creating user-friendly systems through:  
     1. Knowing the user.  
     2. Usability benchmarks.  
     3. Goal-oriented interaction design.  
     4. Interaction design.

**Goal-Oriented Interaction Design**  
- Defines software based on the user's goals.  
- A **goal** is a final purpose, aim, or objective, while **tasks** are the specific actions taken to achieve the goal.  

**Attributes of Usability**  
- **Effectiveness**  
- **Stability**  
- **Efficiency**  
- **Memorability**  
- **Error Management**  
- **Satisfaction**  
- **Learnability**

---

### **Usability Principles**
1. Adapt usability guidelines to your specific context.  
2. Minimize the steps required to complete tasks.  
3. Clearly guide users through every step.  
4. Provide meaningful feedback, including helpful error messages.  
5. Enable users to undo actions easily.  
6. Ensure system responsiveness with appropriate response times.  

---

### **Computer vs. Humans**
1. **Computers**:  
   - Error-free, deterministic, and sequential.  
2. **Humans**:  
   - Prone to errors, irrational, and random.  

---

### **Technology Supporting User Interfaces**
1. **Input Devices** (e.g., keyboard, mouse).  
2. **Output Devices** (e.g., monitors, speakers).  
3. **High-Speed Processing**  
4. **Networking**

---

### **Interaction Design vs. Interface Design**
- **Interface Design**: Acts as the intermediary between system code and user.  
- **Interaction Design**: Focuses on the system's functions, behavior, and presentation.

---

### **Usability Evaluation**
**Types of Usability Evaluation**  
1. **Exploratory**: Examines how the system is used.  
2. **Predictive**: Estimates the system's future performance.  
3. **Formative**: Focuses on improving the system.  
4. **Summative**: Measures how good the system is.  

**Methods of Usability Evaluation**  
1. **Usability Inspection**: Specialists analyze interface design.  
   - **Guideline Checking**: Comparing interfaces against detailed guidelines.  
   - **Cognitive Walkthrough**: A team tests the system as novice users.  
   - **Action Analysis**: Estimates task completion time by breaking tasks into steps.  
2. **Usability Testing**: Testing the system with real users.  
   - Necessary because intuitions can be wrong, and designers often find their own systems easy to use.  
   - **Types of Empirical Testing**:  
     - **Co-discovery**: Users collaborate while interacting with the system.  
     - **Formal Experiments**: Controlled experiments with specific variables.  
     - **Query Techniques**: Surveys or interviews to gather feedback.  
     - **Usage Studies**: Observations of how users interact with the system.  

---

### **Design Rules**
Designing for maximum usability is the ultimate goal of interaction design.  

1. **Principles of Usability**: Broad understanding of usability concepts.  
2. **Standards and Guidelines**: Provide specific directions for design.  
3. **Design Patterns**: Capture and reuse effective design solutions.  

**Types of Design Rules**  
1. **Principles**: Abstract and general; low authority, high generality.  
2. **Standards**: Specific and authoritative; high authority, limited application.  
3. **Guidelines**: Provide general guidance; low authority, broad application.  

---

### **Principles That Support Usability**
1. **Learnability**:  
	The ease with which new users can begin effective interaction and achieve maximal performance
	   - **Predictability**: Predicting the effect of future actions based on past interactions.  
     - **Familiarity**: Leveraging prior knowledge.  
     - **Generalizability**: Extending specific knowledge to new experiences.  
2. **Flexibility**:  
   - the multiplicity of ways the user and system exchange information.  
     - **Multithreading**: Performing multiple tasks simultaneously.  
     - **Task Migratability**: Flexibility in task execution.  
3. **Robustness**:  
   - **Observability**: System's ability to display its status to the user.  
   - **Recoverability**: Allowing users to correct errors effectively.

---
### **Design Rules and Heuristics**

#### **General Design Guidelines**
- Serve as high-level "broad brush" rules for effective design.
- Provide a useful checklist to achieve good design practices.
- Help ensure better designs compared to no structured approach.
- Different frameworks and collections exist, including:
  - **Nielsen’s 10 Heuristics** (see Chapter 9 for details).
  - **Shneiderman’s 8 Golden Rules.**
  - **Norman’s 7 Principles.**

---

#### **Shneiderman’s 8 Golden Rules**
1. **Strive for consistency.**  
   Maintain uniformity in design elements to create a predictable experience.
2. **Enable frequent users to use shortcuts.**  
   Provide accelerators for experienced users to speed up interactions.
3. **Offer informative feedback.**  
   Ensure users receive clear feedback for their actions.
4. **Design dialogs to yield closure.**  
   Create clear sequences with defined start and end points.
5. **Offer error prevention and simple error handling.**  
   Minimize errors and simplify recovery steps when they occur.
6. **Permit easy reversal of actions.**  
   Allow users to undo or redo actions to reduce anxiety.
7. **Support internal locus of control.**  
   Empower users to feel in control of the interface.
8. **Reduce short-term memory load.**  
   Design interfaces that minimize the cognitive effort required to remember details.

---

#### **Norman’s 7 Principles**
1. **Use both knowledge in the world and in the head.**  
   Combine visible cues with memory-based knowledge for better usability.
2. **Simplify the structure of tasks.**  
   Break tasks into manageable steps to reduce complexity.
3. **Make things visible.**  
   Clarify the relationship between actions and their effects (bridging the gulf of execution and evaluation).
4. **Get the mappings right.**  
   Align controls and feedback to user expectations.
5. **Exploit the power of constraints.**  
   Use natural and artificial constraints to guide user behavior.
6. **Design for error.**  
   Anticipate and design for user errors to minimize their impact.
7. **When all else fails, standardize.**  
   Follow established conventions to ensure consistency.

---

#### **HCI Design Patterns**
- Focus on reusing proven solutions to common design challenges.
- Originated from architectural design principles (e.g., Alexander’s patterns).  
  **Key Idea**: A pattern is a reusable solution for a recurring problem in a specific context.

##### **Examples of Design Patterns**
- **Architecture**: "Light on Two Sides of Every Room."  
- **HCI**: "Go back to a safe place."

##### **Characteristics of HCI Design Patterns**
- Capture practical design knowledge rather than theoretical concepts.
- Highlight essential properties of successful designs.
- Represent design knowledge across multiple levels:
  - Social
  - Organizational
  - Conceptual
  - Detailed
- Embody values that promote humane interface design.
- Are intuitive and readable, facilitating communication among stakeholders.
- Serve as part of a "pattern language" to guide the creation of complete designs.

---
### **Implementation Support in Human-Computer Interaction (HCI)**

#### **Programming Tools and Services**
- **Levels of Service for Programmers:**  
  Provide varying levels of support to assist programmers in creating interactive applications.

---

#### **Windowing Systems**
- **Core Support:**  
  Facilitate simultaneous user and system activities through separate windows.  
- **Application Programming and Dialogue Control:**  
  Enable developers to manage how the system interacts with users.  

---

#### **Interaction Toolkits**
- **Purpose:**  
  Simplify programming by aligning it more closely with user-perceived behaviors, bridging the gap between technical implementation and user expectations.

---

#### **User Interface Management Systems (UIMS)**
- **Function:**  
  Manage the relationship between the visual presentation of the interface and the underlying functionality of the application.

---

### **Introduction: The Impact of HCI on Programmers**
- **Evolution of Programming:**  
  Advances in coding have shifted focus from hardware-specific programming to interaction-technique-specific programming.  
- **Layers of Development Tools:**  
  1. **Windowing Systems**  
  2. **Interaction Toolkits**  
  3. **User Interface Management Systems**

---

### **Elements of Windowing Systems**

#### **Device Independence**
- Abstract programming to work across multiple hardware devices using concepts like:
  - **Abstract Terminal Device Drivers**
  - **Image Models for Output and Input:**
    - **Pixels**
    - **PostScript** (e.g., MacOS X, NextStep)
    - **Graphical Kernel System (GKS)**
    - **Programmers’ Hierarchical Interface to Graphics (PHIGS)**

#### **Resource Sharing**
- **Simultaneity of User Tasks:**  
  Windowing systems allow independent processes to run concurrently.  
- **Application Isolation:**  
  Ensures individual applications operate independently within the system.

#### **Roles of a Windowing System**
- Facilitate the creation of graphical interfaces.
- Manage user interactions across multiple applications.
- Coordinate resource sharing effectively.

---

### **Architectures of Windowing Systems**
Three primary software architectures, each handling multiple applications differently:  

1. **Application-Level Management:**  
   - Each application manages all processes independently.  
   - **Challenges:** Synchronization is difficult, reducing application portability.  

2. **Operating System Kernel Management:**  
   - Management responsibilities are embedded within the operating system kernel.  
   - **Limitation:** Applications are tightly tied to the operating system.  

3. **Separate Management Application:**  
   - Management is handled by a distinct application.  
   - **Advantage:** Maximizes portability across different platforms.  

---
Prototyping is the process of creating an early simplified

Evaluation has three main goals: 
- to assess the extent and accessibility of the system’s functionality, 
- to assess users’ experience of the interaction, 
- to identify any specific problems with the system.